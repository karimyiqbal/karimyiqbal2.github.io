<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>karimyiqbal</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">karimyiqbal</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">karimyiqbal</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="karim-iqbal" class="level2">
<h2 class="anchored" data-anchor-id="karim-iqbal">Karim Iqbal</h2>
<p>This is my GitHub website. Please see assignments and research project and share your feedback at kxi220002(at)utdallas.edu</p>
<section id="research-paper" class="level3">
<h3 class="anchored" data-anchor-id="research-paper">Research Paper</h3>
<p>[Research Paperl](pdfs/goodland_finalproject.pdf)</p>
</section>
<section id="research-proposal" class="level3">
<h3 class="anchored" data-anchor-id="research-proposal">Research Proposal</h3>
<p>[Research Proposal](pdfs/goodland_researchproposal.pdf)</p>
</section>
<section id="assignments" class="level3">
<h3 class="anchored" data-anchor-id="assignments">Assignments</h3>
<p><strong>Assignment 1</strong></p>
<p>2a. The questionnaire primarily employs Multiple Choice (MC) questions, supplemented by a Descriptive Block (DB) and a Matrix question. The DB serves as an introductory segment, providing context but not soliciting data. The MC questions, forming the survey’s core, offer predefined choices for concise response gathering. An example includes querying preferences between purchasing or renting movies. The Matrix question, distinct in its format, allows for the simultaneous assessment of various service aspects, streamlining comparative analysis within a singular framework. This combination of question types facilitates an efficient yet comprehensive data collection approach.</p>
<p>2b. The questionnaire of this survey strikes a balance in its composition, primarily utilizing two types of questions. It includes descriptive text blocks, which serve to provide essential instructions or contextual information to the respondents, effectively setting the stage for the survey. Alongside these, the survey incorporates multiple-choice (MC) questions. These questions ask respondents to select from a set of predefined options, offering a clear and structured way to gather data. This combination of descriptive guidance and specific, choice-based questions ensures both clarity and ease of participation, crucial for effective data gathering in a survey context.</p>
<p>2c. The questions are ordered logically, starting with a descriptive text block that likely serves as an introduction or instructions to the respondents. This is followed by multiple-choice questions covering different aspects of movie rental experiences. The questions seem to be grouped by theme, progressing in a way that maintains a logical flow and coherence in the survey.</p>
<p>This analysis is based on the initial elements and the first few questions. For a more detailed understanding, a deeper analysis of each question and its specific content would be necessary.</p>
<p>7. To enhance the respondent experience, a few adjustments could be beneficial. First, considering the survey has 18 questions, ensuring relevance of each question is key to maintain respondent engagement. Additionally, including a few open-ended questions could provide richer, qualitative insights, as the current survey lacks ‘Text Entry’ (TE) type questions. Finally, for questions with more than five options, simplifying choices or using a drop-down format could help prevent respondent fatigue and make the survey more user-friendly.</p>
<p>Further assignment</p>
<p>4. The question delves into demographics beyond just race and ethnicity, probing into aspects like socioeconomic status and highest level of education. This approach enables a more comprehensive understanding of diversity and inclusion. By gaining insights into these deeper demographic facets, it becomes possible to draw nuanced conclusions about the respondents’ backgrounds and how these relate to their perspectives on diversity and inclusiveness.<br>
</p>
<p><strong>Assignment 2</strong></p>
<p>Use Google Trends website to: Search Trump, Biden and Election</p>
<p>Download the data Analyze the data</p>
<p>Dates</p>
<p>In the period analyzed from 10/10/2018 to 10/10/2023, the most searches for Trump, Biden, and election happened during the first week of November 2020, which is right before the presidential election. Two other spikes are seen around Jan 6th events and the mid-term elections in November 2022.</p>
<p>Intervals</p>
<p>The intervals between peaks are irregular, but the most notable peaks align with important political events, such as elections. The data shows seasonal trends with higher search interest around the time of elections and significant political events.</p>
<p><img src="images/Assignment2.jpg" class="img-fluid" width="406"></p>
<p>Use gtrendsR package to do a. (use gtrendsR01.R program)</p>
<p><img src="images/Assignment2 gtrendsR-01.jpg" class="img-fluid" width="372"></p>
<p>What are the differences between the two methods?</p>
<p>Google Trends provides an intuitive web interface that allows users to easily visualize search interest over time and download data, but for deeper analysis or data manipulation, one must use external tools. In contrast, gtrendsR allows for direct data manipulation and complex analyses, leveraging R’s statistical capabilities. While Google Trends offers a simple and direct way to look at trends, gtrendsR provides more flexibility in data presentation, enabling users to customize plots extensively and integrate Google Trends data with other datasets for comprehensive analysis.</p>
<p><strong>Assignment 3</strong></p>
<p>Text Analytics using quanteda</p>
<p>1.Read about the package quanteda at https://quanteda.io/</p>
<p>2.Download quanteda_textanalytics01.R from Teams</p>
<p>3.Analyze:</p>
<p>a. Biden-Xi summit data</p>
<p>Quanteda package tokenized the tweets, created a document-feature matrix, and applied Latent Semantic Analysis to uncover underlying patterns in the text data. It identified and analyzed the most frequent hashtags and user mentions, providing a network visualization of these elements. The provided dataset is a comprehensive collection of Twitter data focused on the summit between US President Biden and Chinese President Xi Jinping in November 2021. It features over 1,000 observations, each representing a Twitter post. These posts include direct tweets, quotes, and retweets related to articles discussing the two leaders. The data also contains user information, such as the names of the individuals tweeting.</p>
<p><img src="images/Assignment 3a.jpg" class="img-fluid" width="307"></p>
<p><img src="images/Assignment3a1.png" class="img-fluid" width="368"></p>
<p>b. US presidential inaugural speeches</p>
<p>This dataset comprises records of US presidential inaugural addresses from President Eisenhower’s era through to President Trump’s tenure. Graphical representations within the dataset illustrate the prevalence of specific terms like “people,” “American,” and “communist” across these speeches.</p>
<p>i. Any similarities and differences over time and among presidents?</p>
<p>The lexical dispersion analysis of U.S. presidential inaugural speeches from Eisenhower to Biden shows that the usage of “American” has become more frequent in recent administrations, suggesting a contemporary emphasis on national identity, while the term “people” consistently figures across speeches, underscoring a constant focus on democratic values.</p>
<p><img src="images/Assignment 3.jpg" class="img-fluid" width="399"></p>
<p>The word “American” was seldom used in the past but saw a notable rise starting with Clinton’s administration, indicating a shift in presidential rhetoric toward patriotism. Additionally, the term “communist” saw heightened usage during the Nixon and Reagan eras, aligning with the peak of the Red Scare, reflecting the socio-political concerns of the times.</p>
<p>4. What is Wordfish? (Do research on quanteda website)</p>
<p>Wordfish is a method used for analyzing texts in a one-dimensional framework, primarily focusing on how frequently words occur within documents. This technique is adept at assessing the positioning of documents on a singular axis, such as an ideological spectrum. By evaluating the usage frequency of specific words, Wordfish helps in organizing and interpreting data, as exemplified in the analysis of inaugural speech data.</p>
<p><strong>Assignment 5</strong></p>
<p>YouTube data</p>
<ol type="1">
<li><p>Run YouTubenews01.R. (prerequisites: YouTube developer API). Repeat the data collection of CNN's channel stats, video stats and comments.</p>
<p>Despite getting ClientID and ClientSecret, the script kept resulting in errors.</p></li>
<li><p>Analyze the stats and comments</p></li>
<li><p>Can you use quanteda to analyze the text data from YouTube comments?</p></li>
</ol>
<p><strong>Assignment 6</strong></p>
<p>Web scraping</p>
<ol type="1">
<li><p>Run textmining01.R, rvest01.R and rvest02.R.</p></li>
<li><p>Organize the data in data frames and run text analytics (e.g.&nbsp;Wordcloud)</p>
<p><img src="images/Rplot.png" class="img-fluid" width="228"></p>
<p>MLK Speech</p>
<p><img src="images/Assignment 6 Churchill.jpg" class="img-fluid" width="320"></p>
<p>Churchill speech</p></li>
<li><p>Challenge: How to download multiple pdf/data files using webscraping methods?</p>
<p>To download multiple PDF or data files using web scraping methods, we need to identify the URLs of the files we want to download. This is typically done using a web scraping library like rvest in R to parse the HTML of the webpage and extract the URLs. Once we have the URLs, we can use a function like download.file() in R, in combination with a loop, to programmatically download each file.</p></li>
</ol>
<p><strong>Assignment 7</strong></p>
<p>Government data and parallel processing</p>
<ol type="1">
<li>Run govdata01.R and parallel01.R. – Task completed</li>
<li>Start planning for storage and computational resources: Note the space and time taken.</li>
</ol>
<p>a. Plan data management (e.g.&nbsp;database)</p>
<p>It took 10.462103 minutes to get 234 records and the total size of PDFs downloaded was 106509630 bytes.</p>
<ol start="3" type="1">
<li><p>Organize the data in data frames – Task completed.</p></li>
<li><p>Learn other data storage methods (e.g.&nbsp;arrow, feather, parquet)</p>
<p>After learning about these storage methods, I found that for large, complex datasets, Parquet is often the best choice due to its efficiency in storage and speed in analytics queries. For smaller datasets or when high-speed input output is more critical, Feather is a good choice. If you need to share data between different programming languages or tools, Arrow provides a great platform due to its language-agnostic design.</p></li>
</ol>
<p><strong>Assignment 8</strong></p>
<p>Census data and Spatial data</p>
<p>Read A Guide to Working with US Census Data in R - Task completed</p>
<p>Get an API key from Census using this website (http://api.census.gov/data/key_signup.html) - Task completed</p>
<p>Run spatialdata01.R and spatialdata02.R. - Task completed</p>
<p>The script “spatialdata01.R” retrieves Census data concerning the median age for each U.S. state in 2019, utilizing the ggplot2 package for visualization. It then generates a thematic map displaying the variations in median age across different states in the U.S.</p>
<p><img src="images/8a.jpg" class="img-fluid" width="356"></p>
<p>The script “spatialdata2” gathers and displays Census data regarding income in Texas, with a special focus on Dallas County for the year 2020. It employs a range of color intensities on the maps to represent various income levels in Texas and Dallas.</p>
<p><img src="images/8b.jpg" class="img-fluid" width="361"></p>
<p><img src="images/8c.jpg" class="img-fluid" width="358"></p>
<p>Compare different years of data (e.g.&nbsp;2010 and 2020)</p>
<p>Year 2010</p>
<p><img src="images/8d.jpg" class="img-fluid" width="376"></p>
<p><img src="images/8e.jpg" class="img-fluid" width="398"></p>
<p><img src="images/8f.jpg" class="img-fluid" width="358"></p>
<p>Year 2020</p>
<p><img src="images/8g.jpg" class="img-fluid" width="340"></p>
<p>Texas and Dallas income level graphs are already shared above in question 3.</p>
<p>In the Dallas area, there’s a noticeable overall uptick in income, particularly in the neighborhoods to the north of downtown Dallas. While incomes were fairly uniform in 2010, especially in the southern regions, more pronounced income disparities have emerged by 2020. The median age reported in the Census has shown little variation, with a marginally reduced median.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>